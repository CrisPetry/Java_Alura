						ESTRUTURA DE DADOSArray[]Como declarar um array[] = tipo_de_dados[] nome_da_variavel = new tipo_de_dados[tamanho]; ex: int[] idades = new int[5];Quando o array não é manualmente não inicializado, ele sempre irá inicializar como 0; Quando inicializamos o array do tipo primitivo(int, double) com o tamanho, lá no HEAP(memória de objetos) irá reservar o espaço com o tamanho informado e inicializar as posições com o valor 0. Array[] de referênciaQuando iniciamos um array de referência com o número de elementos do array (tamanho), lá no HEAP irá ser reservado este espaço na memória e os valores alocados nas posições serão null.No entanto também há uma forma literal. Literal, nesse contexto, significa usar valores diretamente, menos burocrático, mais direito. Veja a diferença:int[] refs = {1,2,3,4,5};Usamos as chaves {} para indicar que se trata de um array e os valores já ficam declarados dentro das chaves.-> Um array é uma estrutura de dados e serve para guardar elementos (valores primitivos ou referências)-> Arrays usam colchetes ([]) sintaticamente-> Arrays têm um tamanho fixo!-> Um array também é um objeto!-> Arrays são zero-based (o primeiro elemento se encontra na posição 0)-> Um array é sempre inicializado com os valores padrões.-> Ao acessar uma posição inválida recebemos a exceção ArrayIndexOutOfBoundException-> Arrays possuem um atributo length para saber o tamanho-> A forma literal de criar uma Array, com o uso de chaves {}.-> uma array do tipo Object pode guardar qualquer tipo de referência-> quando convertemos uma referência genérica para uma referência mais específica é preciso usar um type cast-> o cast só compila quando é possível, mesmo assim pode falhar na hora de rodar-> quando o type cast falha podemos receber uma ClassCastException-> para receber valores ao chamar o programa Java na linha de comando podemos usar o array String[] no método mainP : Array não sabe quantas posições estão ocupadas (apenas tamanho total)-> Isso é uma grande desvantagem. Não queremos saber quantos elementos um array pode ter, mas sim quantos elementos realmente já existem no array.P : Array tem um tamanho fixo (não pode crescer dinamicamente)-> Uma vez criado, o array sempre terá o mesmo tamanho de elementos. Isso é muito ruim quando não sabemos exatamente quantos elementos precisamos guardar.P : Sintaxe fora do padrão "OO Java"-> Os arrays realmente têm a sua própria sintaxe, o que dificulta a legibilidade do código.ArrayList().add = adicionar a lista de elementos.size = quantidade de elementos na lista.remove = remover da listaVeja as afirmações sobre a ArrayList:a) Guarda referências.b) É do pacote java.utilc) Usa internamente um arrayArrayList<>() é conhecido como generics onde podemos delimitar o tipo de dado que aquela ArrayList irá aceitar e armazenar, como por exemplo ArrayList<Conta> lista = new ArrayList<Conta>(); Delimitamos assim que o compilador apenas aceitará dados do tipo Conta. parametrizamos a ArrayList usando <>. Há uma variação/simplificação que entrou no Java 1.7. O código abaixo é equivalente a alternativa:ArrayList<Cliente> lista = new ArrayList<>();-> que a classe java.util.ArrayList encapsula o uso do array e oferece vários métodos de mais alto nível-> que uma lista guarda referencias-> como usar métodos size, get, remove	-> como usar o foreach para iterar a ArrayList-> que os generics parametrizam classes-> que no caso da ArrayList podemos definir o tipo dos elementos através de generics-> as listas garantem a ordem de inserção. Isso significa que ao iterar recebemos os elementos na mesma ordem que eles foram inseridos.-> as listas sempre possuem um índice (podemos acessar o elemento através da posição).Além disso, existe mais uma característica: lista aceitam elementos duplicados-> como implementar o método equals para definir a igualdade-> que o método equals é utilizado pelas listas-> que existe mais uma lista, a java.util.LinkedList-> a diferença entre ArrayList e LinkedList-> a interface java.util.List que define os métodos da lista-> o java.util.Vector, que é uma ArrayList thread safe-> a interface java.util.Collection que é a interface de todas as coleções-> as listas são sequencias que aceitam elementos duplicados-> os conjuntos (java.util.Set) também são coleções, mas não aceitam duplicados nem são listasWRAPPER INTEGERQuando tentamos adicionar um valor primitivo a uma lista, o java faz o autoboxing, ou seja, atribui um objeto ao primitivo convertendo esse int em um Integer. -> São classes que contém funcionalidades e encapsulam a variável de tipo primitivo! criamos objetos dessas classes para envolver ou embrulhar uma valor primitivo. Há várias funcionalidades nessas classes que ajudam no dia a dia.----------------------------------------------------------------------tipos primitivos 				Wrappers             -double (8 bytes)				java.lang.Double     -			float (4 bytes)					java.lang.Float      -----------------------------------------------------------------------long (8 bytes)					java.lang.Long       -int (4 bytes)					java.lang.Integer    -short (2 bytes)					java.lang.Short      -byte (1 byte)					java.lang.Byte       -char (2 bytes)					java.lang.Character  -boolean						java.lang.Boolean    -----------------------------------------------------------------------O interessante é que o char é quase um tipo numérico. Ele tem dois bytes, igual o tipo short mas não usa o primeiro bit para guardar o sinal. Em outras palavras, o char só guarda números positivos. Isso significa que o char consegue guardar valores entre 0 e 65536 (2^16).-> para cada primitivo existe uma classe chamada Wrapper-> para guardar um primitivo numa coleção é preciso criar um objeto que embrulha o valor-> a criação do objeto Wrapper é chamada de autoboxing-> a retirada do valor primitivo do objeto Wrapper é chamada de unboxing-> autoboxing e unboxing acontecem automaticamente.-> as classes wrapper possuem vários métodos auxiliares, por exemplo para o parsing-> todas as classes wrappers que representam um valor numérico possuem a classe java.lang.Number como mãeP: No mundo Java existem duas interfaces para definir o critério de ordenação dos elementos de uma lista. As interfaces são:-> java.util.Comparator (o comparator é um parâmetro do método sort da lista e da classe Collections).-> java.lang.Comparable (para definir a ordem natural dos elementos!).P: o que significa ordem natural?-> É a ordem definida pelo próprio elemento da lista. Correto, no nosso exemplo a classe Conta define o seu próprio critério de ordenação implementando a interface java.lang.Comparable. Nesse caso não é utilizado nenhum Comparator.Pode ser utilizado o Comparator como parâmetro do método sort da lista ou implementar na classe a interface Comparable para poder definir o critério de ordenação. Neste segundo caso para conseguir fazer o lista.sort() utilizar a ordem natural é preciso passar como parâmetro o valor null: lista.sort(null);-> Para ordenar uma lista é preciso definir um critério de ordenação-> Há duas formas de definir esse critério-> Pela interface Comparator-> Pela interface Comparable (ordem natural)-> O algoritmo de ordenação já foi implementado-> Na lista no método sort-> Na classe Collections pelo método sort-> A classe Collections é uma fachada com vários métodos auxiliares para trabalhar com as coleções, principalmente listasP: Como chamamos esse objeto que só encapsula uma função/método/procedimento?-> Function Object. Um objeto que criamos para encapsular uma função ou método. As classes anônimas facilitam um pouco a criação desses objetos. 